# kubecon-talk
## INTRO
Hey. I'm Eirik aka clux on github and am one of the main maintainers on kube-rs.

Today, talking about the kubernetes api, generic assumptions and invariants that kubernetes wants to maintain, but is for the lack of actual generics in the language, is in many cases a best-effort ordeal, and in other cases completely broken.

We'll talk a little bit about how a richer type system - like rust's - gives us more a lot more for free in this regard, but with the caveat that we are still building on top of kubernetes' api, which is written in go.
=> Broken invariants need to be respected in rust land as well.

But this is still meant to be a pretty positive talk. Yes, some invariants are broken, but kubernetes is still remarkably consistent in its api despite shortcomings of the language.

Additionally, this might serve as a bit of a high level view into async rust (which was released on stable in just about a year ago - so there's been tons of advancements there). IMO, it's now in a really good place, library ecosystem is great and starting to properly stabilize. However, the learning curve is ever present.

## THE GOOD PARTS
### apimachinery types.go
This file is great.

TypeMeta.
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L41-L56
Every object as a kind/version - flattened into the root structure like `Pod`

ObjectMeta.
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L110-L282
Every object MUST Have metadata, and must look like this.

Everything in this file is great. OwnerReference, GetOptions, ListOptions, DeleteOptions, PatchOptions. All parameters that the API accepts encapsulated into common structs from this root file. Error responses.

List types.
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L914-L923
Look at items there. A dynamic collection so it can be re-used.

APIResource.
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L999-L1032
standardising where we we can get information of what Kind

LabelSelectors.
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L1095-L1104
that sits inside ListOptions, so there's a generic way of filtering

### client-go consistency
methods the same on most types
getters/updaters/patchers/replacers/listers/deleters
https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/apps/v1/deployment.go#L41-L55
they take the same parameters everywhere
watch possible on everything
WatchEvent packs the object itself inside
100K LOC. Generated by client-gen.

### api endpoints
url consistency lets us make easy mappings between types and urls

## BROKEN ASSUMPTIONS
### Object<Spec, Status>
What people tell you it's like. Bring up some snowflakes.

### Optional everything
even though a resource having a name inside a namespace is a fundamental idea

metadata.name optional (yes, because of `generatename`..)
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L117-L118
so there's a decicion that now causes all clients to have to deref
rather than distinguish between partial data accepted as input and finalized stored input

### Optional metadata
screenshot code with the +optional... in pod?
https://github.com/kubernetes/api/blob/master/core/v1/types.go#L3667-L3686

### empty api group
in general we have url consistency, but not for core types (in empty group)

### conditions..
https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L1367

### watch is broken
mention many issues, stale rvs, relisting required from a client re-watch every <300s. so much data (node informer, hah). can't filter out events.
writing controller to reconcile? you'll trigger your own loop.. (TODO: verify)

### watchevent is weird for bookmarks
does not pack object inside

## WHERE TO DRAW THE LINE
Show where we are. Evolving target.


## THANKS
first a few thanks.. I'll be talking about a grab bag of different things, but from the perspective of [kube-rs](https://github.com/clux/kube-rs/).

- Arnav Singh / @Arnavion for k8s-openapi
generates structures from openapi schemas, as well as factoring out several traits that is then implemented for these structures
the project really is the lynchpin that makes any generics possible

### Metadata
From k8s-metadata. Trait with associated constants. Codegen fills this in. Lynchpin.

### Resource
Show the core props + what we need to use api. Params objects. One FILE!
CAVEAT: load-bearing pluralize.

### Api<K> trait where K: Metadata
Show how to generate all those methods you saw in client-go across all types with a blanket impl.

### In general: Lean on types
trying to catch errors with type safety rather than --pattern and passive code generation (like kubebuilder)

### Watch
Mention hard parts briefly. Chunking. Async. impl Stream == async iterator.
..but re-list

## Runtime
How to build on top of watch and the api?

- Teo K. RÃ¶ijezon / @teozkr for kube-runtime
Figured out an entirely Stream based solution for reflectors/watchers and controllers, and rewrote the entire runtime part of `kube`. It's an amazing techncial achievement that we're just barely starting to gain the benefit of.

### Watcher
Informer-like. But FSM.

### Reflector
Builds on top of watcher and adds a store. Move ensures no use after construction. Writer disappears. No weird contracts in godoc. Enforce it in the code.

### Controller
The big one...


## Building Controllers
not rehashing best practices. most advice from kubebuilder / controller-runtime applies. reconcile needs to be idempotent, check state of the world before you redo all the work on a duplicate event. use server side apply.

async/streams/tokio/web frameworks/metrics/tracing that makes writing controllers in rust very enjoyable. THOUGH WITH CAVEAT;

## Examples
Mention streams need to be polled.
Mention boxing.

## Caveats
Rough edges. Testing story (can be done now with streams).
